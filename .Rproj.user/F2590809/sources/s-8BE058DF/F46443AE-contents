library("tidyverse")
library("profvis")

test_input <- readLines("day15/test_input.txt")
day15_input <- readLines("day15/day15_input.txt")
#add up the risk levels of each position you enter

#the starting position is never entered

#Your goal is to find a path with the lowest total risk.
#you cannot move diagonally

#What is the lowest total risk of any path from the top left to the bottom right?
input <- test_input



parse_input <- function(input){
  ll <- nchar(input[1])
  
  out <- data.frame(input) %>% 
    mutate(row_id = 1:nrow(.)) %>% 
    separate_rows(input, sep = "") %>% 
    filter(!input == "") %>% 
    mutate(col_id = rep_len(1:ll, length.out = nrow(.)), 
           pos_id = 1:nrow(.), 
           input = as.numeric(input))
}




find_winner <- function(input){
  out <- parse_input(input)
  rv <- out %>% select(pos_id, riskval_addl = input)
  end <- max(out$pos_id)
  v <- max(out$row_id)
  
  winner <- tibble()
  i <- 1
  path <- tibble("pos_id" = 1, 
                 "riskval" = out$input[out$pos_id == pos_id])
  
  ##
  while(nrow(path) > 0){
    pos_id <- path$pos_id[1]
    
    directions <- list("down" =pos_id + v,
                       "right" = pos_id + 1,
                       "left" = pos_id - 1,
                       "up" = pos_id - v) %>% 
      keep(~all(.x > 0)) %>% 
      compact()
    
    #if there's no winner, take the most direct route
    if(length(winner) == 0){
      if((i %% 2) == 0){
        directions <- directions$right
      } else {
        directions <- directions$down
      }
    } 
    
    new_path <- tibble("pos_id" = unlist(directions, use.names = FALSE)) %>% 
      left_join(rv, by = "pos_id") %>%
      bind_cols(path[path$pos_id == pos_id, "riskval"]) %>% 
      mutate(riskval = riskval + as.numeric(riskval_addl)) %>% 
      select(-riskval_addl)
    
    path <- bind_rows(new_path, path[path$pos_id != pos_id,])
    
    #check riskval is less than winner's riskval
    if(length(winner) > 0){
      path <- path[path$riskval < winner$riskval,] 
    } 
    
    #prune any duplicate final nodes to the one with the minimum current risk value
    #sort to start with path of minimum risk
    path <- path %>% 
      group_by(pos_id) %>% 
      mutate(count = n())
    
    if(any(path$n > 1)){
      path <- path %>% 
        slice(which.min(riskval)) %>% 
        arrange(riskval) %>% 
        ungroup() %>% 
        select(-count)
    } else {
      path <- path %>% 
        ungroup() %>% 
        select(-count)
    }

    
    if(any(path$pos_id == end)){
      #if it did and the new winner has a lower risk value, replace the winner
      if(length(winner) != 0){
        
        if(any(path$riskval < winner$riskval)){
          winner <- path %>% 
            filter(pos_id == end) %>% 
            slice(which.min(riskval))
        }
    
        path <- path[path$pos_id != end,]
        
      } else {
        winner <- path[path$pos_id == end]
        path <- path[path$pos_id != end,]
        
        if(!is.na(i)){
          i <- NA
          path <- tibble("pos_id" = 1, 
                         "riskval" = out$input[out$pos_id == pos_id])
        }
      }
    }
    
    #print(head(path$path))
    print(nrow(path))
    i <- i + 1
  }
  
  winner <- winner %>% mutate(riskval = riskval - 1)
  print(winner$riskval)
  return(winner)
  
}


tick <- Sys.time()
profvis(find_winner(test_input))
tock <- Sys.time()
tick-tock

tick <- Sys.time()
final_riskval <- find_winner(day15_input)
tock <- Sys.time()
tick-tock
