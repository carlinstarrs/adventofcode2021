library("tidyverse")
library("profvis")

test_input <- readLines("day15/test_input.txt")
day15_input <- readLines("day15/day15_input.txt")
#add up the risk levels of each position you enter

#the starting position is never entered

#Your goal is to find a path with the lowest total risk.
#you cannot move diagonally

#What is the lowest total risk of any path from the top left to the bottom right?
input <- day15_input

#this puzzle gave me a hard time, I came up with a few solutions that worked
#but were not fast enough. I wound up adapting this python solution: 
#https://github.com/tbpaolini/Advent-of-Code/blob/master/2021/Day%2015/chiton.py

traverse_cave <- function(input){

  cave_map <- str_split(input, "") %>%
    unlist() %>%
    as.numeric() %>%
    matrix(nrow = nchar(input[1]))
  
  end <- c(nrow(cave_map), ncol(cave_map))
  start_risk <- cave_map[1,1]
  
  not_visited <- setNames(list(c(1,1)), start_risk)
  
  visited <- list()
  
  #while(length(visited) < 1000){
  while(length(not_visited) != 0){
    if(length(visited) > 1000) browser()
    least_risky <- which.min(as.numeric(names(not_visited)))
    node <- not_visited[least_risky][[1]]
    risk <- as.numeric(names(not_visited[least_risky]))
    
    if(all(node == end)){
      return(print(risk - start_risk))
      next
    }
    
    if(length(detect(visited, ~all(.x == node))) > 0) {
      not_visited <- not_visited[-least_risky]
      next
    }
    
    choices <- list("down" = c(node[1] + 1, node[2]), 
                    "right" = c(node[1], node[2] + 1),
                    "up" = c(node[1] - 1, node[2]),
                    "left" = c(node[1], node[2] - 1))
    
    for(i in 1:length(choices)){
      next_node <- choices[[i]]
      
      if((0 < next_node[1] & next_node[1] <= end[1]) & (0 < next_node[2] & next_node[2] <= end[2])){
        next_risk <- risk + cave_map[next_node[1], next_node[2]]
        not_visited <- c(not_visited, setNames(list(next_node), next_risk))
      }
    }
    

    
    visited <- c(visited, list(node))
    
    print(paste("not visited:", length(not_visited), "visited:", length(visited)))
  }
}
tick <- Sys.time()
traverse_cave(test_input)
tock <- Sys.time()
tick - tock

tick <- Sys.time()
profvis(traverse_cave(day15_input))
tock <- Sys.time()
tick - tock


# find_winner <- function(input){
#   out <- parse_input(input)
#   rv <- out %>% select(pos_id, riskval_addl = input)
#   end <- max(out$pos_id)
#   v <- max(out$row_id)
#   
#   start_risk  <- 
#   winner <- tibble()
#   i <- 1
#   path <- tibble("pos_id" = 1, 
#                  "riskval" = 0)
#   
#   visited <- tibble("pos_id" = out$pos_id, 
#                     "min_riskval" = Inf)
#  tryCatch(
#   ##
#   while(nrow(path) > 0){
#     pos_id <- path$pos_id[order(path$riskval)][1]
#     
#     directions <- list("down" =pos_id + v,
#                        "right" = pos_id + 1,
#                        "left" = pos_id - 1,
#                        "up" = pos_id - v) %>% 
#       keep(~all(.x > 0 & .x <= end)) %>%
#       #keep(~!.x %in% visited$pos_id[!is.infinite(visited$min_riskval)]) %>%
#       compact()
#     
#     #if(length(directions) == 0 & is.na(i)) browser()
#     
#     if(length(directions) == 0) {
#       path <- path[order(path$riskval),][-1,]
#       next
#     }
#     
#     #if there's no winner, take the most direct route
#     if(length(winner) == 0){
#       if((i %% 2) == 0){
#         directions <- directions$right
#       } else {
#         directions <- directions$down
#       }
#     } 
#     
#     new_path <- tibble("pos_id" = unlist(directions, use.names = FALSE)) %>% 
#       left_join(rv, by = "pos_id") %>%
#       bind_cols(path[path$pos_id == pos_id, "riskval"]) %>% 
#       mutate(riskval = riskval + as.numeric(riskval_addl)) %>% 
#       left_join(visited, by = c("pos_id")) 
#     
#     
#     if(any(new_path$riskval < visited$min_riskval)){
#       smol <- new_path[new_path$riskval < new_path$min_riskval,]
#       smol <- smol[order(smol$riskval),][1,]
#       visited <- visited[!(visited$pos_id %in% pos_id),]
#       visited <- bind_rows(visited, tibble("pos_id" = pos_id, "min_riskval" = smol$riskval))
#     } 
# 
#     path <- bind_rows(new_path[,c("pos_id", "riskval")], path[path$pos_id != pos_id,])
#     
#     #check riskval is less than winner's riskval
#     if(length(winner) > 0){
#       if(any(path$riskval < winner$riskval)){
#         path <- path[path$riskval < winner$riskval,]
#       }
#     } 
#     
#     # #prune any duplicate final nodes to the one with the minimum current risk value
#     # #sort to start with path of minimum risk
#     # path <- path %>% 
#     #   group_by(pos_id) %>% 
#     #   mutate(count = n())
#     # 
#     # if(any(path$n > 1)){
#     #   path <- path %>% 
#     #     slice(which.min(riskval)) %>% 
#     #     arrange(riskval) %>% 
#     #     ungroup() %>% 
#     #     select(-count)
#     # } else {
#     #   path <- path %>% 
#     #     ungroup() %>% 
#     #     select(-count)
#     # }
#     
#     
#     if(any(path$pos_id == end)){
#       #if it did and the new winner has a lower risk value, replace the winner
#       if(length(winner) != 0){
#         
#         if(any(path$riskval < winner$riskval)){
#           winner <- path %>% 
#             filter(pos_id == end) %>% 
#             slice(which.min(riskval))
#         }
#         
#         path <- path[path$pos_id != end,]
#         
#       } else {
#         winner <- path[path$pos_id == end]
#         path <- path[path$pos_id != end,]
#         
#         if(!is.na(i)){
#           i <- NA
#           path <- tibble("pos_id" = 1, 
#                          "riskval" = 0)
#           
#           # visited <- tibble("pos_id" = NA, 
#           #                   "riskval" = NA)
#         }
#       }
#     }
#     
#     #print(head(path$path))
#     print(nrow(path))
#     i <- i + 1
#   }
#   ,
#   error = function(e) browser()
#   )
#   
#   winner <- winner %>% mutate(riskval = riskval - 1)
#   print(winner$riskval)
#   return(winner)
#   
# }
# 
# 
# tick <- Sys.time()
# find_winner(test_input)
# tock <- Sys.time()
# tick-tock
# 
# tick <- Sys.time()
# final_riskval <- find_winner(day15_input)
# tock <- Sys.time()
# tick-tock
